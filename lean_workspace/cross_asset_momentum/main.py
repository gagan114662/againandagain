# region imports
from AlgorithmImports import *
import numpy as np
from collections import defaultdict
# endregion

class CrossAssetMomentum(QCAlgorithm):
    """
    CROSS-ASSET MOMENTUM - Global Macro with Crypto & Commodities
    Momentum across equities, bonds, commodities, crypto, and forex
    Targets: CAGR > 40%, Sharpe > 1.5, maximum diversification
    """

    def initialize(self):
        self.set_start_date(2014, 1, 1)  # Bitcoin futures availability
        self.set_end_date(2023, 12, 31)
        self.set_cash(100000)
        
        self.set_brokerage_model(BrokerageName.INTERACTIVE_BROKERS_BROKERAGE, AccountType.MARGIN)
        
        # MEGA UNIVERSE - All Asset Classes
        
        # Equities
        self.add_equity("SPY", Resolution.DAILY).set_leverage(5.0)    # US Large Cap
        self.add_equity("QQQ", Resolution.DAILY).set_leverage(5.0)    # US Tech
        self.add_equity("IWM", Resolution.DAILY).set_leverage(5.0)    # US Small Cap
        self.add_equity("EFA", Resolution.DAILY).set_leverage(5.0)    # Developed International
        self.add_equity("EEM", Resolution.DAILY).set_leverage(5.0)    # Emerging Markets
        self.add_equity("VGK", Resolution.DAILY).set_leverage(5.0)    # Europe
        self.add_equity("EWJ", Resolution.DAILY).set_leverage(5.0)    # Japan
        self.add_equity("FXI", Resolution.DAILY).set_leverage(5.0)    # China
        
        # Leveraged Equity ETFs
        self.add_equity("TQQQ", Resolution.DAILY).set_leverage(3.0)   # 3x NASDAQ
        self.add_equity("UPRO", Resolution.DAILY).set_leverage(3.0)   # 3x S&P
        self.add_equity("SOXL", Resolution.DAILY).set_leverage(3.0)   # 3x Semiconductors
        
        # Bonds
        self.add_equity("TLT", Resolution.DAILY).set_leverage(6.0)    # 20+ Year Treasury\n        self.add_equity("IEF", Resolution.DAILY).set_leverage(6.0)    # 7-10 Year Treasury\n        self.add_equity("SHY", Resolution.DAILY).set_leverage(6.0)    # 1-3 Year Treasury\n        self.add_equity("HYG", Resolution.DAILY).set_leverage(6.0)    # High Yield Corporate\n        self.add_equity("LQD", Resolution.DAILY).set_leverage(6.0)    # Investment Grade Corporate\n        self.add_equity("EMB", Resolution.DAILY).set_leverage(6.0)    # Emerging Market Bonds\n        \n        # Commodities\n        self.add_equity("GLD", Resolution.DAILY).set_leverage(6.0)    # Gold\n        self.add_equity("SLV", Resolution.DAILY).set_leverage(6.0)    # Silver\n        self.add_equity("USO", Resolution.DAILY).set_leverage(4.0)    # Oil\n        self.add_equity("UNG", Resolution.DAILY).set_leverage(4.0)    # Natural Gas\n        self.add_equity("DBC", Resolution.DAILY).set_leverage(5.0)    # Diversified Commodities\n        self.add_equity("PPLT", Resolution.DAILY).set_leverage(5.0)   # Platinum\n        self.add_equity("CORN", Resolution.DAILY).set_leverage(5.0)   # Corn\n        self.add_equity("WEAT", Resolution.DAILY).set_leverage(5.0)   # Wheat\n        \n        # Crypto Proxies (Bitcoin miners and crypto ETFs)\n        self.add_equity("GBTC", Resolution.DAILY).set_leverage(4.0)   # Bitcoin Trust\n        self.add_equity("RIOT", Resolution.DAILY).set_leverage(3.0)   # Bitcoin Miner\n        self.add_equity("MARA", Resolution.DAILY).set_leverage(3.0)   # Bitcoin Miner\n        \n        # Currencies\n        self.add_equity("UUP", Resolution.DAILY).set_leverage(8.0)    # US Dollar\n        self.add_equity("FXE", Resolution.DAILY).set_leverage(8.0)    # Euro\n        self.add_equity("FXY", Resolution.DAILY).set_leverage(8.0)    # Yen\n        self.add_equity("FXB", Resolution.DAILY).set_leverage(8.0)    # British Pound\n        self.add_equity("FXA", Resolution.DAILY).set_leverage(8.0)    # Australian Dollar\n        \n        # Real Estate\n        self.add_equity("VNQ", Resolution.DAILY).set_leverage(5.0)    # US REITs\n        self.add_equity("VNQI", Resolution.DAILY).set_leverage(5.0)   # International REITs\n        \n        # Sectors\n        self.add_equity("XLK", Resolution.DAILY).set_leverage(4.0)    # Technology\n        self.add_equity("XLF", Resolution.DAILY).set_leverage(4.0)    # Financials\n        self.add_equity("XLE", Resolution.DAILY).set_leverage(4.0)    # Energy\n        self.add_equity("XLV", Resolution.DAILY).set_leverage(4.0)    # Healthcare\n        self.add_equity("XLI", Resolution.DAILY).set_leverage(4.0)    # Industrials\n        \n        # Alternative strategies\n        self.add_equity("VXX", Resolution.DAILY).set_leverage(3.0)    # Volatility\n        self.add_equity("SVXY", Resolution.DAILY).set_leverage(3.0)   # Short Volatility\n        \n        # Asset universe organization\n        self.asset_classes = {\n            "EQUITY_US": ["SPY", "QQQ", "IWM", "TQQQ", "UPRO", "SOXL"],\n            "EQUITY_INTL": ["EFA", "EEM", "VGK", "EWJ", "FXI"],\n            "BONDS": ["TLT", "IEF", "SHY", "HYG", "LQD", "EMB"],\n            "COMMODITIES": ["GLD", "SLV", "USO", "UNG", "DBC", "PPLT", "CORN", "WEAT"],\n            "CRYPTO": ["GBTC", "RIOT", "MARA"],\n            "CURRENCIES": ["UUP", "FXE", "FXY", "FXB", "FXA"],\n            "REAL_ESTATE": ["VNQ", "VNQI"],\n            "SECTORS": ["XLK", "XLF", "XLE", "XLV", "XLI"],\n            "VOLATILITY": ["VXX", "SVXY"]\n        }\n        \n        # Create flat list of all symbols\n        self.all_symbols = []\n        for asset_class in self.asset_classes.values():\n            self.all_symbols.extend(asset_class)\n        \n        # Multi-timeframe momentum indicators\n        self.momentum_indicators = {}\n        for symbol in self.all_symbols:\n            self.momentum_indicators[symbol] = {\n                "momentum_1w": self.momp(symbol, 5),      # 1 week\n                "momentum_1m": self.momp(symbol, 21),     # 1 month\n                "momentum_3m": self.momp(symbol, 63),     # 3 months\n                "momentum_6m": self.momp(symbol, 126),    # 6 months\n                "momentum_12m": self.momp(symbol, 252),   # 12 months\n                "rsi_14": self.rsi(symbol, 14),\n                "atr_20": self.atr(symbol, 20),\n                "sma_50": self.sma(symbol, 50),\n                "sma_200": self.sma(symbol, 200),\n                "bb_20": self.bb(symbol, 20, 2)\n            }\n        \n        # Performance tracking\n        self.trades = 0\n        self.wins = 0\n        self.losses = 0\n        self.peak = 100000\n        self.max_dd = 0\n        self.returns = []\n        self.last_value = 100000\n        self.positions = {}\n        \n        # Cross-asset momentum parameters\n        self.momentum_lookback = 63          # 3 months primary\n        self.momentum_threshold = 0.05       # 5% momentum threshold\n        self.max_total_positions = 8         # Max positions across all assets\n        self.max_per_asset_class = 2         # Max 2 positions per asset class\n        self.position_size_base = 0.4        # 40% base position size\n        self.rebalance_frequency = 5         # Rebalance every 5 days\n        self.volatility_target = 0.25        # 25% annual volatility target\n        \n        # Regime detection\n        self.market_regime = "NORMAL"        # RISK_ON, RISK_OFF, NORMAL, CRISIS\n        self.regime_indicators = {\n            "spy_trend": self.sma("SPY", 200),\n            "vix_level": self.sma("VXX", 20),\n            "dollar_strength": self.sma("UUP", 50),\n            "bond_trend": self.sma("TLT", 50)\n        }\n        \n        # Cross-asset correlation tracking\n        self.correlation_window = 60\n        self.price_history = defaultdict(lambda: [])\n        \n        # Daily rebalancing and regime detection\n        self.schedule.on(\n            self.date_rules.every_day(),\n            self.time_rules.after_market_open("SPY", 30),\n            self.cross_asset_momentum_scan\n        )\n        \n        # Weekly portfolio rebalancing\n        self.schedule.on(\n            self.date_rules.week_start(),\n            self.time_rules.after_market_open("SPY", 60),\n            self.portfolio_rebalance\n        )\n        \n        # Regime update\n        self.schedule.on(\n            self.date_rules.every_day(),\n            self.time_rules.after_market_open("SPY", 90),\n            self.update_market_regime\n        )\n    \n    def cross_asset_momentum_scan(self):\n        \"\"\"Daily cross-asset momentum analysis\"\"\"\n        \n        # Performance tracking\n        current_value = self.portfolio.total_portfolio_value\n        if current_value > self.peak:\n            self.peak = current_value\n            \n        drawdown = (self.peak - current_value) / self.peak\n        if drawdown > self.max_dd:\n            self.max_dd = drawdown\n            \n        # Emergency protection\n        if drawdown > 0.18:\n            self.liquidate()\n            self.trades += 1\n            return\n            \n        # Track returns\n        ret = (current_value - self.last_value) / self.last_value if self.last_value > 0 else 0\n        self.returns.append(ret)\n        self.last_value = current_value\n        \n        # Update price history for correlations\n        for symbol in self.all_symbols:\n            price = self.securities[symbol].price\n            if price > 0:\n                self.price_history[symbol].append(price)\n                if len(self.price_history[symbol]) > self.correlation_window:\n                    self.price_history[symbol] = self.price_history[symbol][-self.correlation_window:]\n        \n        # Calculate momentum scores for all assets\n        momentum_scores = self.calculate_cross_asset_momentum()\n        \n        # Filter and rank opportunities\n        opportunities = self.rank_momentum_opportunities(momentum_scores)\n        \n        # Execute trades based on regime\n        if self.market_regime == "RISK_ON":\n            self.execute_risk_on_trades(opportunities)\n        elif self.market_regime == "RISK_OFF":\n            self.execute_risk_off_trades(opportunities)\n        elif self.market_regime == "CRISIS":\n            self.execute_crisis_trades(opportunities)\n        else:\n            self.execute_normal_trades(opportunities)\n    \n    def calculate_cross_asset_momentum(self):\n        \"\"\"Calculate momentum scores across all asset classes\"\"\"\n        \n        scores = {}\n        \n        for symbol in self.all_symbols:\n            if not self.indicators_ready(symbol):\n                continue\n                \n            indicators = self.momentum_indicators[symbol]\n            \n            # Multi-timeframe momentum composite\n            mom_1w = indicators["momentum_1w"].current.value\n            mom_1m = indicators["momentum_1m"].current.value\n            mom_3m = indicators["momentum_3m"].current.value\n            mom_6m = indicators["momentum_6m"].current.value\n            mom_12m = indicators["momentum_12m"].current.value\n            \n            # Weighted momentum score (recent gets higher weight)\n            momentum_score = (mom_1w * 0.3 + mom_1m * 0.25 + mom_3m * 0.2 + \n                            mom_6m * 0.15 + mom_12m * 0.1)\n            \n            # Technical strength\n            rsi = indicators["rsi_14"].current.value\n            price = self.securities[symbol].price\n            sma_50 = indicators["sma_50"].current.value\n            sma_200 = indicators["sma_200"].current.value\n            \n            # Trend strength\n            trend_strength = 0\n            if price > sma_50 > sma_200:\n                trend_strength = 1.0\n            elif price > sma_50:\n                trend_strength = 0.5\n            elif price > sma_200:\n                trend_strength = 0.3\n            \n            # Volatility adjustment\n            atr = indicators["atr_20"].current.value\n            volatility_score = 1 / (1 + atr / price) if price > 0 else 0\n            \n            # Combined score\n            combined_score = momentum_score * trend_strength * volatility_score\n            \n            scores[symbol] = {\n                "momentum": momentum_score,\n                "trend": trend_strength,\n                "volatility": volatility_score,\n                "combined": combined_score,\n                "rsi": rsi\n            }\n        \n        return scores\n    \n    def rank_momentum_opportunities(self, scores):\n        \"\"\"Rank opportunities by asset class and overall strength\"\"\"\n        \n        opportunities = {}\n        \n        for asset_class, symbols in self.asset_classes.items():\n            class_opportunities = []\n            \n            for symbol in symbols:\n                if symbol in scores and scores[symbol]["combined"] > 0:\n                    class_opportunities.append({\n                        "symbol": symbol,\n                        "asset_class": asset_class,\n                        "score": scores[symbol]["combined"],\n                        "momentum": scores[symbol]["momentum"],\n                        "rsi": scores[symbol]["rsi"]\n                    })\n            \n            # Sort by score within asset class\n            class_opportunities.sort(key=lambda x: x["score"], reverse=True)\n            opportunities[asset_class] = class_opportunities\n        \n        return opportunities\n    \n    def execute_risk_on_trades(self, opportunities):\n        \"\"\"Execute trades during risk-on regime\"\"\"\n        \n        # Prefer risk assets: Equities, Crypto, Commodities\n        risk_on_classes = ["EQUITY_US", "EQUITY_INTL", "CRYPTO", "COMMODITIES", "SECTORS"]\n        \n        selected_trades = []\n        \n        for asset_class in risk_on_classes:\n            if asset_class in opportunities:\n                top_opportunities = opportunities[asset_class][:self.max_per_asset_class]\n                for opp in top_opportunities:\n                    if (opp["momentum"] > self.momentum_threshold and \n                        opp["rsi"] < 75):  # Not overbought\n                        selected_trades.append(opp)\n        \n        # Execute top trades\n        self.execute_selected_trades(selected_trades[:self.max_total_positions])\n    \n    def execute_risk_off_trades(self, opportunities):\n        \"\"\"Execute trades during risk-off regime\"\"\"\n        \n        # Prefer safe haven assets: Bonds, Gold, Dollar\n        risk_off_classes = ["BONDS", "CURRENCIES", "VOLATILITY"]\n        risk_off_symbols = ["GLD", "SLV"]  # Add gold/silver from commodities\n        \n        selected_trades = []\n        \n        for asset_class in risk_off_classes:\n            if asset_class in opportunities:\n                top_opportunities = opportunities[asset_class][:self.max_per_asset_class]\n                selected_trades.extend(top_opportunities)\n        \n        # Add gold/silver if showing momentum\n        if "COMMODITIES" in opportunities:\n            for opp in opportunities["COMMODITIES"]:\n                if opp["symbol"] in risk_off_symbols and opp["momentum"] > 0:\n                    selected_trades.append(opp)\n        \n        self.execute_selected_trades(selected_trades[:self.max_total_positions])\n    \n    def execute_crisis_trades(self, opportunities):\n        \"\"\"Execute trades during crisis regime\"\"\"\n        \n        # Crisis assets: Long volatility, long bonds, long gold, long dollar\n        crisis_symbols = ["VXX", "TLT", "GLD", "UUP"]\n        \n        selected_trades = []\n        \n        for asset_class, class_opps in opportunities.items():\n            for opp in class_opps:\n                if opp["symbol"] in crisis_symbols:\n                    selected_trades.append(opp)\n        \n        self.execute_selected_trades(selected_trades[:4])  # Max 4 crisis positions\n    \n    def execute_normal_trades(self, opportunities):\n        \"\"\"Execute trades during normal regime\"\"\"\n        \n        # Diversified across all asset classes\n        selected_trades = []\n        \n        for asset_class, class_opps in opportunities.items():\n            if len(class_opps) > 0:\n                # Take top 1 from each asset class\n                top_opp = class_opps[0]\n                if (top_opp["momentum"] > self.momentum_threshold and\n                    20 < top_opp["rsi"] < 80):  # Not at extremes\n                    selected_trades.append(top_opp)\n        \n        # Sort all by score and take top positions\n        selected_trades.sort(key=lambda x: x["score"], reverse=True)\n        self.execute_selected_trades(selected_trades[:self.max_total_positions])\n    \n    def execute_selected_trades(self, selected_trades):\n        \"\"\"Execute the selected trades with dynamic position sizing\"\"\"\n        \n        # Clear existing positions not in new selection\n        current_symbols = set(self.positions.keys())\n        new_symbols = set([trade["symbol"] for trade in selected_trades])\n        \n        for symbol in current_symbols - new_symbols:\n            if self.portfolio[symbol].invested:\n                self.liquidate(symbol)\n                self.trades += 1\n                if symbol in self.positions:\n                    del self.positions[symbol]\n        \n        # Execute new positions\n        if selected_trades:\n            position_size = self.position_size_base / len(selected_trades)\n            \n            for trade in selected_trades:\n                symbol = trade["symbol"]\n                \n                # Dynamic sizing based on momentum strength\n                momentum_multiplier = min(2.0, max(0.5, abs(trade["momentum"]) * 10))\n                adjusted_size = position_size * momentum_multiplier\n                \n                if symbol not in self.positions:\n                    if trade["momentum"] > 0:\n                        self.set_holdings(symbol, adjusted_size)\n                    else:\n                        self.set_holdings(symbol, -adjusted_size)  # Short negative momentum\n                    \n                    self.trades += 1\n                    self.positions[symbol] = {\n                        "entry_price": self.securities[symbol].price,\n                        "asset_class": trade["asset_class"],\n                        "momentum_score": trade["momentum"],\n                        "entry_time": self.time\n                    }\n                    \n                    self.debug(f"CROSS-ASSET: {symbol} ({trade['asset_class']}) - {adjusted_size:.2%}")\n    \n    def update_market_regime(self):\n        \"\"\"Update market regime based on cross-asset signals\"\"\"\n        \n        if not self.regime_indicators_ready():\n            return\n            \n        # Get regime signals\n        spy_price = self.securities["SPY"].price\n        spy_trend = self.regime_indicators["spy_trend"].current.value\n        vix_level = self.securities["VXX"].price\n        vix_ma = self.regime_indicators["vix_level"].current.value\n        dollar_strength = self.securities["UUP"].price\n        dollar_ma = self.regime_indicators["dollar_strength"].current.value\n        bond_price = self.securities["TLT"].price\n        bond_trend = self.regime_indicators["bond_trend"].current.value\n        \n        # Regime logic\n        previous_regime = self.market_regime\n        \n        if vix_level > vix_ma * 1.5:  # High volatility\n            self.market_regime = "CRISIS"\n        elif (spy_price > spy_trend * 1.05 and  # Strong equity uptrend\n              vix_level < vix_ma * 0.8 and      # Low volatility\n              dollar_strength < dollar_ma):      # Weak dollar (risk on)\n            self.market_regime = "RISK_ON"\n        elif (spy_price < spy_trend * 0.95 or   # Equity downtrend\n              bond_price > bond_trend * 1.02):   # Flight to bonds\n            self.market_regime = "RISK_OFF"\n        else:\n            self.market_regime = "NORMAL"\n        \n        # Log regime changes\n        if previous_regime != self.market_regime:\n            self.debug(f"REGIME CHANGE: {previous_regime} -> {self.market_regime}")\n    \n    def portfolio_rebalance(self):\n        \"\"\"Weekly portfolio rebalancing\"\"\"\n        \n        # Calculate portfolio concentration\n        total_value = self.portfolio.total_portfolio_value\n        position_weights = {}\n        \n        for symbol in self.positions.keys():\n            if self.portfolio[symbol].invested:\n                weight = abs(self.portfolio[symbol].holdings_value) / total_value\n                position_weights[symbol] = weight\n        \n        # Rebalance if needed\n        max_weight = max(position_weights.values()) if position_weights else 0\n        if max_weight > 0.6:  # If any position > 60%, rebalance\n            self.debug("REBALANCING: Position too concentrated")\n            # Trigger new momentum scan\n            self.cross_asset_momentum_scan()\n    \n    def on_data(self, data):\n        \"\"\"Real-time position management\"\"\"\n        \n        for symbol in list(self.positions.keys()):\n            if not self.portfolio[symbol].invested:\n                if symbol in self.positions:\n                    del self.positions[symbol]\n                continue\n                \n            position = self.positions[symbol]\n            entry_price = position["entry_price"]\n            current_price = self.securities[symbol].price\n            \n            if entry_price <= 0:\n                continue\n                \n            pnl = (current_price - entry_price) / entry_price\n            \n            # Adjust for short positions\n            if self.portfolio[symbol].is_short:\n                pnl = -pnl\n            \n            # Asset class specific exits\n            asset_class = position["asset_class"]\n            \n            if asset_class in ["CRYPTO", "VOLATILITY"]:\n                # Tighter stops for volatile assets\n                if pnl > 0.15:  # 15% profit\n                    self.liquidate(symbol)\n                    self.trades += 1\n                    self.wins += 1\n                    del self.positions[symbol]\n                elif pnl < -0.08:  # 8% stop\n                    self.liquidate(symbol)\n                    self.trades += 1\n                    self.losses += 1\n                    del self.positions[symbol]\n            else:\n                # Normal stops\n                if pnl > 0.10:  # 10% profit\n                    self.liquidate(symbol)\n                    self.trades += 1\n                    self.wins += 1\n                    del self.positions[symbol]\n                elif pnl < -0.05:  # 5% stop\n                    self.liquidate(symbol)\n                    self.trades += 1\n                    self.losses += 1\n                    del self.positions[symbol]\n    \n    def indicators_ready(self, symbol):\n        \"\"\"Check if indicators are ready for symbol\"\"\"\n        if symbol not in self.momentum_indicators:\n            return False\n        return all(ind.is_ready for ind in self.momentum_indicators[symbol].values())\n    \n    def regime_indicators_ready(self):\n        \"\"\"Check if regime indicators are ready\"\"\"\n        return all(ind.is_ready for ind in self.regime_indicators.values())\n    \n    def on_end_of_algorithm(self):\n        \"\"\"Final cross-asset momentum results\"\"\"\n        \n        years = (self.end_date - self.start_date).days / 365.25\n        final_value = self.portfolio.total_portfolio_value\n        total_return = (final_value - 100000) / 100000\n        cagr = (final_value / 100000) ** (1/years) - 1\n        trades_per_year = self.trades / years\n        \n        # Metrics\n        total_decided = self.wins + self.losses\n        win_rate = self.wins / total_decided if total_decided > 0 else 0\n        avg_profit = total_return / self.trades if self.trades > 0 else 0\n        \n        # Sharpe calculation\n        if len(self.returns) > 100:\n            returns_array = np.array(self.returns[-252*5:])\n            if len(returns_array) > 50:\n                mean_return = np.mean(returns_array)\n                std_return = np.std(returns_array)\n                if std_return > 0:\n                    sharpe = (mean_return / std_return) * np.sqrt(252)\n                else:\n                    sharpe = 0\n            else:\n                sharpe = 0\n        else:\n            sharpe = 0\n            \n        self.log("=== CROSS-ASSET MOMENTUM RESULTS ===")\n        self.log(f"Final Value: ${final_value:,.2f}")\n        self.log(f"Total Return: {total_return:.2%}")\n        self.log(f"CAGR: {cagr:.2%}")\n        self.log(f"Sharpe Ratio: {sharpe:.2f}")\n        self.log(f"Total Trades: {self.trades}")\n        self.log(f"Trades/Year: {trades_per_year:.1f}")\n        self.log(f"Win Rate: {win_rate:.2%}")\n        self.log(f"Avg Profit/Trade: {avg_profit:.2%}")\n        self.log(f"Max Drawdown: {self.max_dd:.2%}")\n        \n        # Asset class breakdown\n        self.log("=== ASSET CLASS PERFORMANCE ===")\n        for asset_class, symbols in self.asset_classes.items():\n            class_return = 0\n            for symbol in symbols:\n                if self.portfolio[symbol].invested:\n                    weight = self.portfolio[symbol].holdings_value / self.portfolio.total_portfolio_value\n                    class_return += weight\n            self.log(f"{asset_class}: {class_return:.2%} allocation")\n        \n        # Target validation\n        self.log("=== TARGET VALIDATION ===")\n        t1 = cagr > 0.25\n        t2 = sharpe > 1.0\n        t3 = trades_per_year > 100\n        t4 = avg_profit > 0.0075\n        t5 = self.max_dd < 0.20\n        \n        self.log(f"CAGR > 25%: {'PASS' if t1 else 'FAIL'} - {cagr:.2%}")\n        self.log(f"Sharpe > 1.0: {'PASS' if t2 else 'FAIL'} - {sharpe:.2f}")\n        self.log(f"Trades > 100/yr: {'PASS' if t3 else 'FAIL'} - {trades_per_year:.1f}")\n        self.log(f"Profit > 0.75%: {'PASS' if t4 else 'FAIL'} - {avg_profit:.2%}")\n        self.log(f"Drawdown < 20%: {'PASS' if t5 else 'FAIL'} - {self.max_dd:.2%}")\n        \n        self.log(f"TARGETS ACHIEVED: {sum([t1,t2,t3,t4,t5])}/5")\n        \n        self.log("=== STRATEGY SUMMARY ===")\n        self.log("Global cross-asset momentum with maximum diversification")\n        self.log("9 asset classes: Equities, Bonds, Commodities, Crypto, Currencies, REITs, Sectors, Volatility")\n        self.log("Multi-timeframe momentum analysis (1w to 12m)")\n        self.log("Regime-adaptive positioning (Risk On/Off/Crisis/Normal)")\n        self.log("Up to 8x leverage on currencies, 6x on bonds, 5x on equities")\n        self.log("Dynamic position sizing based on momentum strength")