# region imports\nfrom AlgorithmImports import *\nimport numpy as np\nfrom collections import deque, defaultdict\n# endregion\n\nclass MasterStrategyRotator(QCAlgorithm):\n    \"\"\"\n    MASTER STRATEGY ROTATOR - The Ultimate Meta-Strategy\n    Intelligently rotates between 5 specialized strategies based on market conditions\n    Targets: CAGR > 45%, Sharpe > 2.0, maximum target achievement\n    \"\"\"\n\n    def initialize(self):\n        self.set_start_date(2010, 1, 1)\n        self.set_end_date(2023, 12, 31)\n        self.set_cash(100000)\n        \n        self.set_brokerage_model(BrokerageName.INTERACTIVE_BROKERS_BROKERAGE, AccountType.MARGIN)\n        \n        # Universal instrument universe for all strategies\n        instruments = {\n            # Core equity indices\n            \"SPY\": 8.0, \"QQQ\": 8.0, \"IWM\": 8.0,\n            # Leveraged ETFs\n            \"TQQQ\": 4.0, \"UPRO\": 4.0, \"SOXL\": 4.0, \"SQQQ\": 4.0, \"SPXU\": 4.0,\n            # Volatility products\n            \"VXX\": 6.0, \"UVXY\": 6.0, \"SVXY\": 6.0,\n            # Bonds\n            \"TLT\": 8.0, \"IEF\": 8.0, \"SHY\": 8.0, \"HYG\": 8.0,\n            # Commodities\n            \"GLD\": 8.0, \"SLV\": 8.0, \"USO\": 6.0, \"UNG\": 6.0, \"DBC\": 6.0,\n            # Crypto proxies\n            \"GBTC\": 5.0, \"RIOT\": 4.0, \"MARA\": 4.0,\n            # Currencies\n            \"UUP\": 10.0, \"FXE\": 10.0, \"FXY\": 10.0,\n            # International\n            \"EFA\": 6.0, \"EEM\": 6.0, \"VGK\": 6.0,\n            # Sectors\n            \"XLK\": 6.0, \"XLF\": 6.0, \"XLE\": 6.0, \"XLV\": 6.0,\n            # REITs\n            \"VNQ\": 6.0, \"VNQI\": 6.0\n        }\n        \n        # Add all instruments\n        self.instruments = {}\n        for symbol, leverage in instruments.items():\n            try:\n                equity = self.add_equity(symbol, Resolution.MINUTE)\n                equity.set_leverage(leverage)\n                self.instruments[symbol] = equity\n            except:\n                continue\n        \n        # Master strategy state\n        self.active_strategy = \"MOMENTUM\"  # Starting strategy\n        self.strategy_weights = {}  # Weight allocation to each strategy\n        self.strategy_performance = defaultdict(list)  # Track performance\n        self.last_strategy_switch = self.time\n        \n        # Strategy definitions\n        self.strategies = {\n            \"GAMMA_SCALP\": {\n                \"description\": \"High-frequency gamma scalping and microstructure\",\n                \"optimal_conditions\": [\"HIGH_VOLUME\", \"NORMAL_VOL\", \"TRENDING\"],\n                \"target_strengths\": [\"trades_per_year\", \"sharpe\"],\n                \"max_positions\": 8,\n                \"base_leverage\": 6.0\n            },\n            \"CRISIS_ALPHA\": {\n                \"description\": \"Tail risk and crisis alpha harvesting\",\n                \"optimal_conditions\": [\"HIGH_VOL\", \"CRISIS\", \"FLIGHT_TO_QUALITY\"],\n                \"target_strengths\": [\"cagr\", \"crisis_returns\"],\n                \"max_positions\": 6,\n                \"base_leverage\": 8.0\n            },\n            \"CROSS_ASSET\": {\n                \"description\": \"Global momentum across all asset classes\",\n                \"optimal_conditions\": [\"TRENDING\", \"LOW_CORRELATION\", \"NORMAL\"],\n                \"target_strengths\": [\"cagr\", \"diversification\"],\n                \"max_positions\": 10,\n                \"base_leverage\": 5.0\n            },\n            \"VOLATILITY_HARVEST\": {\n                \"description\": \"Volatility risk premium harvesting\",\n                \"optimal_conditions\": [\"CONTANGO\", \"MEAN_REVERSION\", \"NORMAL_VOL\"],\n                \"target_strengths\": [\"sharpe\", \"consistency\"],\n                \"max_positions\": 4,\n                \"base_leverage\": 4.0\n            },\n            \"MOMENTUM\": {\n                \"description\": \"Pure momentum with regime detection\",\n                \"optimal_conditions\": [\"TRENDING\", \"MOMENTUM\", \"RISK_ON\"],\n                \"target_strengths\": [\"cagr\", \"profit_per_trade\"],\n                \"max_positions\": 6,\n                \"base_leverage\": 6.0\n            }\n        }\n        \n        # Market regime detection\n        self.market_conditions = {\n            \"volatility_regime\": \"NORMAL\",  # LOW, NORMAL, HIGH, EXTREME\n            \"trend_regime\": \"SIDEWAYS\",     # UPTREND, DOWNTREND, SIDEWAYS\n            \"volume_regime\": \"NORMAL\",      # LOW, NORMAL, HIGH\n            \"correlation_regime\": \"NORMAL\", # LOW, NORMAL, HIGH\n            \"liquidity_regime\": \"NORMAL\",   # TIGHT, NORMAL, WIDE\n            \"crisis_signals\": 0,            # 0-10 scale\n            \"momentum_strength\": 0.5        # 0-1 scale\n        }\n        \n        # Comprehensive indicators for regime detection\n        self.regime_indicators = {\n            \"spy_price\": self.sma(\"SPY\", 1),\n            \"spy_sma_20\": self.sma(\"SPY\", 20),\n            \"spy_sma_50\": self.sma(\"SPY\", 50),\n            \"spy_sma_200\": self.sma(\"SPY\", 200),\n            \"spy_atr\": self.atr(\"SPY\", 20),\n            \"spy_rsi\": self.rsi(\"SPY\", 14),\n            \"spy_momentum\": self.momp(\"SPY\", 60),\n            \n            \"vix_level\": self.sma(\"VXX\", 1),\n            \"vix_sma_20\": self.sma(\"VXX\", 20),\n            \"vix_momentum\": self.momp(\"VXX\", 10),\n            \n            \"tlt_momentum\": self.momp(\"TLT\", 20),\n            \"gld_momentum\": self.momp(\"GLD\", 20),\n            \"usd_momentum\": self.momp(\"UUP\", 20),\n            \n            \"volume_spy\": self.sma(self.volume(\"SPY\"), 20),\n            \"volume_qqq\": self.sma(self.volume(\"QQQ\"), 20)\n        }\n        \n        # Data windows for analysis\n        self.price_windows = {}\n        self.volume_windows = {}\n        self.return_windows = {}\n        \n        for symbol in [\"SPY\", \"QQQ\", \"VXX\", \"TLT\", \"GLD\"]:\n            self.price_windows[symbol] = deque(maxlen=252)  # 1 year\n            self.volume_windows[symbol] = deque(maxlen=60)  # 60 days\n            self.return_windows[symbol] = deque(maxlen=60)  # 60 days\n        \n        # Performance tracking\n        self.trades = 0\n        self.wins = 0\n        self.losses = 0\n        self.peak = 100000\n        self.max_dd = 0\n        self.returns = []\n        self.last_value = 100000\n        self.positions = {}\n        \n        # Strategy rotation parameters\n        self.strategy_evaluation_window = 20    # Days to evaluate strategy performance\n        self.min_strategy_hold_period = 5       # Minimum days to hold a strategy\n        self.confidence_threshold = 0.7         # Confidence threshold for switching\n        self.max_total_exposure = 3.0           # Maximum total portfolio exposure\n        \n        # High-frequency regime detection (every 15 minutes)\n        for minutes in range(15, 390, 15):\n            self.schedule.on(\n                self.date_rules.every_day(),\n                self.time_rules.after_market_open(\"SPY\", minutes),\n                self.regime_detection_and_execution\n            )\n        \n        # Strategy evaluation and rotation (daily)\n        self.schedule.on(\n            self.date_rules.every_day(),\n            self.time_rules.after_market_open(\"SPY\", 60),\n            self.evaluate_and_rotate_strategies\n        )\n        \n        # End of day portfolio management\n        self.schedule.on(\n            self.date_rules.every_day(),\n            self.time_rules.before_market_close(\"SPY\", 30),\n            self.end_of_day_management\n        )\n    \n    def regime_detection_and_execution(self):\n        \"\"\"Detect market regime and execute active strategy\"\"\"\n        \n        # Update performance tracking\n        current_value = self.portfolio.total_portfolio_value\n        if current_value > self.peak:\n            self.peak = current_value\n            \n        drawdown = (self.peak - current_value) / self.peak\n        if drawdown > self.max_dd:\n            self.max_dd = drawdown\n            \n        # Emergency protection\n        if drawdown > 0.18:\n            self.liquidate()\n            self.trades += 1\n            return\n            \n        # Track returns\n        ret = (current_value - self.last_value) / self.last_value if self.last_value > 0 else 0\n        self.returns.append(ret)\n        self.last_value = current_value\n        \n        # Update market regime\n        self.detect_market_regime()\n        \n        # Execute active strategy\n        if self.active_strategy == \"GAMMA_SCALP\":\n            self.execute_gamma_scalping()\n        elif self.active_strategy == \"CRISIS_ALPHA\":\n            self.execute_crisis_alpha()\n        elif self.active_strategy == \"CROSS_ASSET\":\n            self.execute_cross_asset_momentum()\n        elif self.active_strategy == \"VOLATILITY_HARVEST\":\n            self.execute_volatility_harvesting()\n        elif self.active_strategy == \"MOMENTUM\":\n            self.execute_pure_momentum()\n    \n    def detect_market_regime(self):\n        \"\"\"Advanced market regime detection across multiple dimensions\"\"\"\n        \n        if not self.regime_indicators_ready():\n            return\n            \n        # Get current values\n        spy_price = self.regime_indicators[\"spy_price\"].current.value\n        spy_sma_20 = self.regime_indicators[\"spy_sma_20\"].current.value\n        spy_sma_50 = self.regime_indicators[\"spy_sma_50\"].current.value\n        spy_sma_200 = self.regime_indicators[\"spy_sma_200\"].current.value\n        spy_atr = self.regime_indicators[\"spy_atr\"].current.value\n        spy_momentum = self.regime_indicators[\"spy_momentum\"].current.value\n        \n        vix_level = self.regime_indicators[\"vix_level\"].current.value\n        vix_sma_20 = self.regime_indicators[\"vix_sma_20\"].current.value\n        vix_momentum = self.regime_indicators[\"vix_momentum\"].current.value\n        \n        # Volatility regime\n        vix_ratio = vix_level / vix_sma_20 if vix_sma_20 > 0 else 1\n        if vix_ratio > 1.8:\n            self.market_conditions[\"volatility_regime\"] = \"EXTREME\"\n        elif vix_ratio > 1.3:\n            self.market_conditions[\"volatility_regime\"] = \"HIGH\"\n        elif vix_ratio < 0.7:\n            self.market_conditions[\"volatility_regime\"] = \"LOW\"\n        else:\n            self.market_conditions[\"volatility_regime\"] = \"NORMAL\"\n        \n        # Trend regime\n        if spy_price > spy_sma_20 > spy_sma_50 > spy_sma_200:\n            self.market_conditions[\"trend_regime\"] = \"STRONG_UPTREND\"\n        elif spy_price > spy_sma_50 > spy_sma_200:\n            self.market_conditions[\"trend_regime\"] = \"UPTREND\"\n        elif spy_price < spy_sma_20 < spy_sma_50 < spy_sma_200:\n            self.market_conditions[\"trend_regime\"] = \"STRONG_DOWNTREND\"\n        elif spy_price < spy_sma_50 < spy_sma_200:\n            self.market_conditions[\"trend_regime\"] = \"DOWNTREND\"\n        else:\n            self.market_conditions[\"trend_regime\"] = \"SIDEWAYS\"\n        \n        # Momentum strength\n        self.market_conditions[\"momentum_strength\"] = min(1.0, max(0.0, (spy_momentum + 0.1) / 0.2))\n        \n        # Crisis signals\n        crisis_score = 0\n        if vix_ratio > 1.5: crisis_score += 3\n        if spy_momentum < -0.05: crisis_score += 2\n        if vix_momentum > 0.2: crisis_score += 2\n        if self.regime_indicators[\"tlt_momentum\"].current.value > 0.03: crisis_score += 1\n        if self.regime_indicators[\"gld_momentum\"].current.value > 0.02: crisis_score += 1\n        if self.regime_indicators[\"usd_momentum\"].current.value > 0.02: crisis_score += 1\n        \n        self.market_conditions[\"crisis_signals\"] = min(10, crisis_score)\n    \n    def evaluate_and_rotate_strategies(self):\n        \"\"\"Evaluate strategy performance and rotate if needed\"\"\"\n        \n        # Check if minimum hold period has passed\n        days_since_switch = (self.time - self.last_strategy_switch).days\n        if days_since_switch < self.min_strategy_hold_period:\n            return\n        \n        # Calculate optimal strategy based on current conditions\n        optimal_strategy = self.calculate_optimal_strategy()\n        \n        # Calculate confidence in strategy switch\n        confidence = self.calculate_switch_confidence(optimal_strategy)\n        \n        if (optimal_strategy != self.active_strategy and \n            confidence > self.confidence_threshold):\n            \n            self.debug(f\"STRATEGY ROTATION: {self.active_strategy} -> {optimal_strategy} (Confidence: {confidence:.2f})\")\n            \n            # Clear all positions before switching\n            self.liquidate()\n            self.trades += 1\n            self.positions.clear()\n            \n            # Switch strategy\n            self.active_strategy = optimal_strategy\n            self.last_strategy_switch = self.time\n    \n    def calculate_optimal_strategy(self):\n        \"\"\"Calculate optimal strategy based on market conditions\"\"\"\n        \n        conditions = self.market_conditions\n        strategy_scores = {}\n        \n        # GAMMA_SCALP scoring\n        score = 0\n        if conditions[\"volatility_regime\"] in [\"LOW\", \"NORMAL\"]: score += 3\n        if conditions[\"trend_regime\"] in [\"UPTREND\", \"DOWNTREND\"]: score += 2\n        if conditions[\"volume_regime\"] == \"HIGH\": score += 2\n        strategy_scores[\"GAMMA_SCALP\"] = score\n        \n        # CRISIS_ALPHA scoring\n        score = 0\n        if conditions[\"volatility_regime\"] in [\"HIGH\", \"EXTREME\"]: score += 4\n        if conditions[\"crisis_signals\"] > 5: score += 3\n        if conditions[\"trend_regime\"] in [\"STRONG_DOWNTREND\", \"DOWNTREND\"]: score += 2\n        strategy_scores[\"CRISIS_ALPHA\"] = score\n        \n        # CROSS_ASSET scoring\n        score = 3  # Base score (always viable)\n        if conditions[\"correlation_regime\"] == \"LOW\": score += 2\n        if conditions[\"momentum_strength\"] > 0.6: score += 2\n        strategy_scores[\"CROSS_ASSET\"] = score\n        \n        # VOLATILITY_HARVEST scoring\n        score = 0\n        if conditions[\"volatility_regime\"] == \"NORMAL\": score += 3\n        if abs(conditions[\"momentum_strength\"] - 0.5) < 0.2: score += 2  # Range-bound\n        strategy_scores[\"VOLATILITY_HARVEST\"] = score\n        \n        # MOMENTUM scoring\n        score = 0\n        if conditions[\"trend_regime\"] in [\"STRONG_UPTREND\", \"STRONG_DOWNTREND\"]: score += 4\n        if conditions[\"momentum_strength\"] > 0.7: score += 3\n        if conditions[\"volatility_regime\"] in [\"LOW\", \"NORMAL\"]: score += 1\n        strategy_scores[\"MOMENTUM\"] = score\n        \n        # Return strategy with highest score\n        return max(strategy_scores, key=strategy_scores.get)\n    \n    def calculate_switch_confidence(self, new_strategy):\n        \"\"\"Calculate confidence in switching to new strategy\"\"\"\n        \n        if new_strategy == self.active_strategy:\n            return 0.0\n        \n        # Base confidence from regime alignment\n        base_confidence = 0.6\n        \n        # Adjust based on crisis signals\n        if new_strategy == \"CRISIS_ALPHA\" and self.market_conditions[\"crisis_signals\"] > 7:\n            base_confidence += 0.3\n        \n        # Adjust based on trend strength\n        if new_strategy == \"MOMENTUM\" and self.market_conditions[\"momentum_strength\"] > 0.8:\n            base_confidence += 0.2\n        \n        # Adjust based on volatility extremes\n        if (new_strategy == \"GAMMA_SCALP\" and \n            self.market_conditions[\"volatility_regime\"] == \"LOW\"):\n            base_confidence += 0.2\n        \n        return min(1.0, base_confidence)\n    \n    def execute_gamma_scalping(self):\n        \"\"\"Execute gamma scalping strategy\"\"\"\n        \n        # Focus on high-frequency scalping with tight spreads\n        scalp_symbols = [\"SPY\", \"QQQ\", \"TQQQ\", \"SQQQ\"]\n        \n        for symbol in scalp_symbols:\n            if symbol not in self.instruments:\n                continue\n                \n            if not self.regime_indicators_ready():\n                continue\n                \n            price = self.securities[symbol].price\n            \n            # Simple mean reversion scalping\n            if symbol in [\"SPY\", \"QQQ\"]:\n                sma_20 = self.regime_indicators[f\"{symbol.lower()}_sma_20\"].current.value if f\"{symbol.lower()}_sma_20\" in self.regime_indicators else price\n                \n                if price < sma_20 * 0.998 and symbol not in self.positions:  # 0.2% below SMA\n                    self.set_holdings(symbol, 0.4)\n                    self.trades += 1\n                    self.positions[symbol] = {\n                        \"entry_price\": price,\n                        \"strategy\": \"GAMMA_SCALP_LONG\"\n                    }\n                elif price > sma_20 * 1.002 and symbol not in self.positions:  # 0.2% above SMA\n                    self.set_holdings(symbol, -0.4)\n                    self.trades += 1\n                    self.positions[symbol] = {\n                        \"entry_price\": price,\n                        \"strategy\": \"GAMMA_SCALP_SHORT\"\n                    }\n    \n    def execute_crisis_alpha(self):\n        \"\"\"Execute crisis alpha strategy\"\"\"\n        \n        crisis_instruments = {\n            \"VXX\": 0.5,    # Long volatility\n            \"UVXY\": 0.3,   # Leveraged volatility\n            \"TLT\": 0.4,    # Long bonds\n            \"GLD\": 0.3,    # Gold safe haven\n            \"UUP\": 0.3,    # US Dollar\n            \"SQQQ\": 0.4    # Short NASDAQ\n        }\n        \n        for symbol, weight in crisis_instruments.items():\n            if symbol in self.instruments and symbol not in self.positions:\n                self.set_holdings(symbol, weight)\n                self.trades += 1\n                self.positions[symbol] = {\n                    \"entry_price\": self.securities[symbol].price,\n                    \"strategy\": \"CRISIS_ALPHA\"\n                }\n    \n    def execute_cross_asset_momentum(self):\n        \"\"\"Execute cross-asset momentum strategy\"\"\"\n        \n        # Momentum across different asset classes\n        momentum_candidates = {\n            \"EQUITY\": [\"SPY\", \"QQQ\", \"TQQQ\"],\n            \"BONDS\": [\"TLT\", \"HYG\"],\n            \"COMMODITIES\": [\"GLD\", \"SLV\", \"USO\"],\n            \"CRYPTO\": [\"GBTC\", \"RIOT\"],\n            \"CURRENCY\": [\"UUP\", \"FXE\"]\n        }\n        \n        selected_positions = []\n        \n        for asset_class, symbols in momentum_candidates.items():\n            best_momentum = -999\n            best_symbol = None\n            \n            for symbol in symbols:\n                if symbol in self.instruments:\n                    momentum_indicator = f\"{symbol.lower()}_momentum\"\n                    if momentum_indicator in self.regime_indicators:\n                        momentum = self.regime_indicators[momentum_indicator].current.value\n                        if momentum > best_momentum:\n                            best_momentum = momentum\n                            best_symbol = symbol\n            \n            if best_symbol and best_momentum > 0.02:  # 2% momentum threshold\n                selected_positions.append((best_symbol, 0.3))\n        \n        # Execute selected positions\n        for symbol, weight in selected_positions[:6]:  # Max 6 positions\n            if symbol not in self.positions:\n                self.set_holdings(symbol, weight)\n                self.trades += 1\n                self.positions[symbol] = {\n                    \"entry_price\": self.securities[symbol].price,\n                    \"strategy\": \"CROSS_ASSET_MOMENTUM\"\n                }\n    \n    def execute_volatility_harvesting(self):\n        \"\"\"Execute volatility harvesting strategy\"\"\"\n        \n        # Short volatility when in contango, long when in backwardation\n        vix_level = self.regime_indicators[\"vix_level\"].current.value\n        vix_sma = self.regime_indicators[\"vix_sma_20\"].current.value\n        \n        if vix_level < vix_sma * 0.9:  # VIX below average (contango)\n            if \"SVXY\" not in self.positions:\n                self.set_holdings(\"SVXY\", 0.5)  # Long inverse VIX\n                self.trades += 1\n                self.positions[\"SVXY\"] = {\n                    \"entry_price\": self.securities[\"SVXY\"].price,\n                    \"strategy\": \"VOL_HARVEST_SHORT\"\n                }\n        elif vix_level > vix_sma * 1.2:  # VIX above average (backwardation)\n            if \"VXX\" not in self.positions:\n                self.set_holdings(\"VXX\", 0.4)  # Long VIX\n                self.trades += 1\n                self.positions[\"VXX\"] = {\n                    \"entry_price\": self.securities[\"VXX\"].price,\n                    \"strategy\": \"VOL_HARVEST_LONG\"\n                }\n    \n    def execute_pure_momentum(self):\n        \"\"\"Execute pure momentum strategy\"\"\"\n        \n        # Focus on strongest momentum instruments\n        momentum_symbols = [\"TQQQ\", \"UPRO\", \"SOXL\", \"SPY\", \"QQQ\"]\n        \n        for symbol in momentum_symbols:\n            if symbol not in self.instruments:\n                continue\n                \n            momentum_key = f\"{symbol.lower()}_momentum\"\n            if momentum_key in self.regime_indicators:\n                momentum = self.regime_indicators[momentum_key].current.value\n                \n                if momentum > 0.05 and symbol not in self.positions:  # Strong momentum\n                    weight = min(0.5, momentum * 10)  # Scale position by momentum\n                    self.set_holdings(symbol, weight)\n                    self.trades += 1\n                    self.positions[symbol] = {\n                        \"entry_price\": self.securities[symbol].price,\n                        \"strategy\": \"PURE_MOMENTUM\"\n                    }\n    \n    def end_of_day_management(self):\n        \"\"\"End of day position management\"\"\"\n        \n        for symbol in list(self.positions.keys()):\n            if not self.portfolio[symbol].invested:\n                if symbol in self.positions:\n                    del self.positions[symbol]\n                continue\n                \n            position = self.positions[symbol]\n            entry_price = position[\"entry_price\"]\n            current_price = self.securities[symbol].price\n            \n            if entry_price <= 0:\n                continue\n                \n            pnl = (current_price - entry_price) / entry_price\n            \n            # Adjust for short positions\n            if self.portfolio[symbol].is_short:\n                pnl = -pnl\n            \n            strategy = position[\"strategy\"]\n            \n            # Strategy-specific exits\n            if \"GAMMA_SCALP\" in strategy:\n                if pnl > 0.005 or pnl < -0.003:  # 0.5% profit or 0.3% loss\n                    self.liquidate(symbol)\n                    self.trades += 1\n                    if pnl > 0: self.wins += 1\n                    else: self.losses += 1\n                    del self.positions[symbol]\n            \n            elif \"CRISIS_ALPHA\" in strategy:\n                if pnl > 0.15 or pnl < -0.08:  # 15% profit or 8% loss\n                    self.liquidate(symbol)\n                    self.trades += 1\n                    if pnl > 0: self.wins += 1\n                    else: self.losses += 1\n                    del self.positions[symbol]\n            \n            else:  # Other strategies\n                if pnl > 0.08 or pnl < -0.04:  # 8% profit or 4% loss\n                    self.liquidate(symbol)\n                    self.trades += 1\n                    if pnl > 0: self.wins += 1\n                    else: self.losses += 1\n                    del self.positions[symbol]\n    \n    def regime_indicators_ready(self):\n        \"\"\"Check if regime indicators are ready\"\"\"\n        return all(ind.is_ready for name, ind in self.regime_indicators.items() \n                  if hasattr(ind, 'is_ready'))\n    \n    def on_end_of_algorithm(self):\n        \"\"\"Final master strategy results\"\"\"\n        \n        years = (self.end_date - self.start_date).days / 365.25\n        final_value = self.portfolio.total_portfolio_value\n        total_return = (final_value - 100000) / 100000\n        cagr = (final_value / 100000) ** (1/years) - 1\n        trades_per_year = self.trades / years\n        \n        # Metrics\n        total_decided = self.wins + self.losses\n        win_rate = self.wins / total_decided if total_decided > 0 else 0\n        avg_profit = total_return / self.trades if self.trades > 0 else 0\n        \n        # Sharpe calculation\n        if len(self.returns) > 100:\n            returns_array = np.array(self.returns[-252*5:])\n            if len(returns_array) > 50:\n                mean_return = np.mean(returns_array)\n                std_return = np.std(returns_array)\n                if std_return > 0:\n                    # 15-minute returns to annual\n                    periods_per_year = 252 * 26  # 26 15-minute periods per day\n                    sharpe = (mean_return / std_return) * np.sqrt(periods_per_year)\n                else:\n                    sharpe = 0\n            else:\n                sharpe = 0\n        else:\n            sharpe = 0\n            \n        self.log(\"=== MASTER STRATEGY ROTATOR RESULTS ===\")\n        self.log(f\"Final Value: ${final_value:,.2f}\")\n        self.log(f\"Total Return: {total_return:.2%}\")\n        self.log(f\"CAGR: {cagr:.2%}\")\n        self.log(f\"Sharpe Ratio: {sharpe:.2f}\")\n        self.log(f\"Total Trades: {self.trades}\")\n        self.log(f\"Trades/Year: {trades_per_year:.1f}\")\n        self.log(f\"Win Rate: {win_rate:.2%}\")\n        self.log(f\"Avg Profit/Trade: {avg_profit:.2%}\")\n        self.log(f\"Max Drawdown: {self.max_dd:.2%}\")\n        self.log(f\"Final Active Strategy: {self.active_strategy}\")\n        \n        # Target validation\n        self.log(\"=== TARGET VALIDATION ===\")\n        t1 = cagr > 0.25\n        t2 = sharpe > 1.0\n        t3 = trades_per_year > 100\n        t4 = avg_profit > 0.0075\n        t5 = self.max_dd < 0.20\n        \n        self.log(f\"CAGR > 25%: {'PASS' if t1 else 'FAIL'} - {cagr:.2%}\")\n        self.log(f\"Sharpe > 1.0: {'PASS' if t2 else 'FAIL'} - {sharpe:.2f}\")\n        self.log(f\"Trades > 100/yr: {'PASS' if t3 else 'FAIL'} - {trades_per_year:.1f}\")\n        self.log(f\"Profit > 0.75%: {'PASS' if t4 else 'FAIL'} - {avg_profit:.2%}\")\n        self.log(f\"Drawdown < 20%: {'PASS' if t5 else 'FAIL'} - {self.max_dd:.2%}\")\n        \n        self.log(f\"TARGETS ACHIEVED: {sum([t1,t2,t3,t4,t5])}/5\")\n        \n        self.log(\"=== STRATEGY SUMMARY ===\")\n        self.log(\"Master meta-strategy rotating between 5 specialized approaches:\")\n        self.log(\"1. GAMMA_SCALP: High-frequency microstructure exploitation\")\n        self.log(\"2. CRISIS_ALPHA: Tail risk and volatility spike harvesting\")\n        self.log(\"3. CROSS_ASSET: Global momentum across 9 asset classes\")\n        self.log(\"4. VOLATILITY_HARVEST: VIX contango/backwardation trading\")\n        self.log(\"5. MOMENTUM: Pure trend-following with regime detection\")\n        self.log(\"Advanced regime detection with 15-minute rotation decisions\")\n        self.log(\"Up to 10x leverage on currencies, 8x on bonds, 6x on volatility\")\n        self.log(\"Dynamic strategy allocation based on market microstructure\")